Imlementing the sokoban solver using a* algorithm and the Manhattan distance as the heuristic.
# Sokoban
The game is played on a board of squares, where each square is a floor or a wall. Some floor squares contain boxes, and some floor squares are marked as storage locations.

The player is confined to the board, and may move horizontally or vertically onto empty squares (never through walls or boxes). The player can also move into a box, which pushes it into the square beyond. Boxes may not be pushed into other boxes or walls, and they cannot be pulled. The number of boxes is equal to the number of storage locations. The puzzle is solved when all boxes are at storage locations.

## Algorithm Used
Weighted A* introduces aweighted formula: f(node)= g(node)+ w∗ h(node) where g(node) is the cost of the path to node, h(node) the estimated cost of getting from node to the goal,and w≥1 is a bias towards states that are closer to the goal. Theoretically, the smaller w is, the better the first solution found will be (i.e., the closer to the optimal solution it will be ...why??). However, differentvalues of w will require different computation times. Since the solution that is found by Weighted A* may not be optimal when w> 1, we can keep searching after we have found a solution. Anytime Weighted A* continues to search until either there are no nodes left to expand (and our best solution is the optimal one) or it runs out of time. Since we have found a path to the goal after the first search iteration, we can introduce a cost bound for pruning: if node has a g(node)+ h(node) value greater than the best path to the goal found so far, we can prune it.
